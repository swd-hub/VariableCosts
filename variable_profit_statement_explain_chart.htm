<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="auther" content="澤田泰人">
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/encoding-japanese/1.0.30/encoding.min.js"></script>
<title>ステップ４：変動損益計算書</title>
<style>
body {
  font-family: 'Segoe UI', sans-serif;
  background-color: #f4f6f8;
  color: #333;
  margin: 30px;
}

h1 {
  font-size: 28px;
  margin-bottom: 20px;
  color: #2c3e50;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.08); /* 軽く奥行き */
}

table {
  table-layout: fixed;
  border-collapse: collapse;
  width: 100%;
  margin-bottom: 40px;
  background: linear-gradient(to bottom, #ffffff, #f8fafc);
  box-shadow: 0 2px 8px rgba(0,0,0,0.08);
  border-radius: 6px;
  /*overflow: hidden;*/
  
  transition: transform 0.2s ease, box-shadow 0.2s ease;
}

table:hover {
  transform: translateY(-3px);
  box-shadow: 0 6px 16px rgba(0,0,0,0.15); /* 浮かせる影 */
}

caption {
  text-align: left;
  font-weight: bold;
  font-size: 22px;
  padding: 12px 16px;
  background: linear-gradient(to bottom, #4daef0, #3498db);
  color: white;
  box-shadow: inset 0 -2px 0 rgba(255,255,255,0.2);
}

th, td {
  border: 1px solid #ddd;
  padding: 8px 10px;
  text-align: right;
  font-size: 20px;
}

th:first-child, td:first-child {
  background: linear-gradient(to bottom, #f5f8fa, #e7ecef);
  text-align: left;
  font-weight: 600;
  width: 200px;
}

thead th {
  background: linear-gradient(to bottom, #f0f3f5, #dfe4e7);
  font-weight: 600;
  text-align: center;
  box-shadow: inset 0 -1px 0 rgba(0,0,0,0.05);
}

tbody tr:hover {
  background: linear-gradient(to bottom, #f9fcff, #eef6ff);
}

input[type="number"], input[type="text"] {
  width: 100px;
  padding: 4px 6px;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: 20px;
  text-align: right;
  box-shadow: inset 1px 1px 3px rgba(0,0,0,0.05); /* 凹み感 */
  transition: box-shadow 0.2s ease, transform 0.2s ease;
}

input[type="number"]:focus, input[type="text"]:focus {
  outline: none;
  box-shadow: 0 0 0 2px rgba(52,152,219,0.3), inset 1px 1px 3px rgba(0,0,0,0.05);
}

#control {
  margin-bottom: 20px;
}

#control button {
  padding: 6px 12px;
  background: linear-gradient(to bottom, #4daef0, #3498db);
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 20px;
  margin-right: 10px;
  box-shadow: 0 3px 6px rgba(0,0,0,0.15);
  transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
}

#control button:hover {
  background: linear-gradient(to bottom, #5eb9f5, #2980b9);
  transform: translateY(-2px);
  box-shadow: 0 5px 10px rgba(0,0,0,0.2);
}

#control button:active {
  transform: translateY(0);
  box-shadow: 0 2px 5px rgba(0,0,0,0.15);
}

#fixedTotal {
  font-weight: bold;
  color: #2c3e50;
}

.summary-table {
  width: 100%;
  margin-bottom: 40px;
}

.summary-table th,
.summary-table td {
  text-align: left;
}

.summary-table input[type="number"] {
  width: 300px;
  box-sizing: border-box;
  font-size: 20px;
  padding: 4px 6px;
  border: 1px solid #ccc;
  border-radius: 4px;
  text-align: right;
  box-shadow: inset 1px 1px 3px rgba(0,0,0,0.05);
}

.speak-on-hover {
  position: relative;
  cursor: pointer;
  overflow: visible; /* 念のため */
}

.speak-on-hover::after {
  content: attr(data-speech);
  position: absolute;
  bottom: calc(100% + 8px);
  left: 50%;
  transform: translateX(-50%);
  background: #333;
  color: #fff;
  padding: 8px 12px;
  border-radius: 6px;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.3s;
  z-index: 9999;
  font-size: 0.8em;
  max-width: 300px; /* ← 横幅を広げる */
  white-space: normal; /* ← 折り返しを許可 */
  box-sizing: border-box;
  word-break: break-word; /* ← 長い単語も折り返し */
}
.speak-on-hover:hover::after {
  opacity: 1;
}

/* 経営全体合計の列幅を安定させる */
table#totalTable {
  table-layout: fixed;
  width: 100%;
  border-collapse: collapse;
}

/* 1列目（見出し）固定幅。必要なら後から個別に上書き可 */
table#totalTable th:first-child {
  width: 200px;
}

/* 見出し・データの整形（共通余白/枠でズレ防止） */
table#totalTable th,
table#totalTable td {
  padding: 8px 10px;
  border: 1px solid #ddd;
  white-space: nowrap;      /* 折返しでの行高変化を防止 */
}

/* 面積入力のはみ出し防止 */
table#totalTable input[type="number"] {
  width: 100px;
  box-sizing: border-box;
}

/* 共通の入力幅（例：セル一杯なら100%） */
#cropTable input[type="number"],
#costTable input[type="number"],
#totalTable input[type="number"] {
  width: 100%;          /* セル幅いっぱいに広げる */
  box-sizing: border-box;
}

canvas {
  width: 100% ;
  height: 500px;
}

</style>
</head>
<body>

<h1>ステップ４：変動損益計算書</h1>

<div id="control">
  <input type="file" accept=".csv" onchange="uploadCSV(event)">
    <button onclick="downloadCSV()">入力データ保存</button>  
      <!-- ここに音声出力のトグルボタンを追加 -->
  <button id="toggleSpeechButton">音声出力：オン</button> 
  <button onclick="addCrop()">作目を追加</button>
  
</div>

<!-- 作目別収入 -->
<table id="cropTable">
  <caption>作目別収入</caption>
  <thead>
    <tr id="cropHeader">
      <th>作目</th>
    </tr>
  </thead>
  <tbody>
    <tr><th>10a収量(kg)</th></tr>
    <tr><th>kg単価（円）</th></tr>
    <tr><th>10a販売額（円）</th></tr>
    <tr><th>10aその他収入（円）</th></tr>
    <tr><th>10a収入計（円）</th></tr>
  </tbody>
</table>

<!-- 変動費・限界利益 -->
<table id="costTable">
  <caption>10aあたり変動費、限界利益</caption>
  <tbody>
    <tr><th>10a資材費（円）</th></tr>
    <tr><th>10a作業委託費（円）</th></tr>
    <tr><th>10aその他変動費（円）</th></tr>
    <tr><th>10a変動費計（円）</th></tr>
    <tr><th>10a限界利益（円）</th></tr>
    <tr><th>限界利益率</th></tr>
  </tbody>
</table>

<!-- 面積との関係 -->
<table id="totalTable">
  <caption>面積との関係</caption>
  <tbody>
    <tr id="totalRow"><th>面積（a）</th></tr>
    <tr><th>収入（円）</th></tr>
    <tr><th>変動費計（円）</th></tr>
    <tr><th>限界利益（円）</th></tr>
    <tr><th>限界利益率(再掲)</th></tr>
  </tbody>
</table>


<!-- 固定費 -->
<table class="summary-table">
  <caption>固定費</caption>
  <tr><th>人件費（円）</th><td><input type="number" id="laborCost" value="" oninput="calculateFixedTotal()"></td></tr>
  <tr><th>減価償却費（円）</th><td><input type="number" id="depreciation" value="" oninput="calculateFixedTotal()"></td></tr>
  <tr><th>支払地代（円）</th><td><input type="number" id="landRent" value="" oninput="calculateFixedTotal()"></td></tr>
  <tr><th>その他固定費（円）</th><td><input type="number" id="otherFixed" value="" oninput="calculateFixedTotal()"></td></tr>
  <tr><th>固定費計（円）</th><td id="fixedTotal">–</td></tr>
</table>

<button id="importFixedCosts">データ取り込み</button>

<br><br>
<!-- 経営全体 -->
<table class="summary-table" id="managementSummary">
  <caption>経営全体</caption>
  <tr><th>販売額（円）</th><td id="sumSales">–</td></tr>
  <tr><th>その他収入（円）</th><td id="sumOtherIncome">–</td></tr>
  <tr><th>収入（円）</th><td id="sumRevenue">–</td></tr>
  <tr><th>変動費（円）</th><td id="sumVarCost">–</td></tr>
  <tr><th>限界利益（円）</th><td id="sumMargin">–</td></tr>
  <tr><th>費用（円）</th><td id="sumCostTotal">–</td></tr>
  <tr><th>利益（円）</th><td id="sumProfit">–</td></tr>
  <tr><th>損益分岐点の収入（円）</th><td id="sumBreakEven">–</td></tr>
</table>

<canvas id="stackedChart" width="800" height="400"></canvas>

<script>
let cropCount = 0;
// 音声出力の状態を管理する変数
let isSpeechEnabled = true; 

// 既存の作目列をクリアする関数
function clearCrops() {
  // cropHeader から作目名のthを削除 (最初の「作目」thを除く)
  const cropHeader = document.getElementById("cropHeader");
  while (cropHeader.children.length > 1) { // 最初のth「作目」は残す
    cropHeader.removeChild(cropHeader.lastChild);
  }

  // cropTable, costTable, totalTable の tbody から動的なtdを削除
  document.querySelectorAll("#cropTable tbody tr").forEach(row => {
    while (row.children.length > 1) { // 最初のthは残す
      row.removeChild(row.lastChild);
    }
  });
  document.querySelectorAll("#costTable tbody tr").forEach(row => {
    while (row.children.length > 1) { // 最初のthは残す
      row.removeChild(row.lastChild);
    }
  });
  document.querySelectorAll("#totalTable tbody tr").forEach(row => {
    while (row.children.length > 1) { // 最初のthは残す
      row.removeChild(row.lastChild);
    }
  });

  cropCount = 0; // 作目数をリセット
}

window.onload = function() {
  for (let i = 0; i < 5; i++) {
    addCrop(); // 初期作目数を設定 (デフォルト5作目)
  }
  calculateFixedTotal(); // 初回計算とグラフ描画
  applySpeechAttributesToCells(); // 音声属性の適用
  attachSpeechListeners(); // 音声イベントリスナーの追加
};


// addCrop 関数を修正して、作目名を引数で受け取れるようにする
function addCrop(cropName = `作目${cropCount + 1}`) {
  cropCount++;

  // === 作目ヘッダ列追加 ===
  const cropHeader = document.getElementById("cropHeader");
  const cropTh = document.createElement("th");
  const nameInput = document.createElement("input");
  nameInput.type = "text";
  nameInput.value = cropName; // 引数で作目名を設定
  nameInput.placeholder = "作目名";
  nameInput.style.width = "150px";
  cropTh.appendChild(nameInput);
  cropHeader.appendChild(cropTh);
  const colIndex = cropTh.cellIndex; // データ列のインデックス

  // === 作目別収入テーブルに列追加 ===
  document.querySelectorAll("#cropTable tbody tr").forEach((row, i) => {
    const td = document.createElement("td");
    if (i === 2 || i === 4) { // 10a販売額, 10a収入計
      td.textContent = "–"; // 自動計算で埋まる行は初期値として –
    } else {
      const input = document.createElement("input");
      input.type = "number";
      input.oninput = () => calculateCrop(colIndex); // 入力時に再計算
      td.appendChild(input);
    }
    row.appendChild(td);
  });

  // === 変動費・限界利益テーブルに列追加 ===
  document.querySelectorAll("#costTable tbody tr").forEach((row, i) => {
    const td = document.createElement("td");
    if (i >= 3) { // 10a変動費計, 10a限界利益, 限界利益率
      td.textContent = "–";
    } else {
      const input = document.createElement("input");
      input.type = "number";
      input.oninput = () => calculateCrop(colIndex);
      td.appendChild(input);
    }
    row.appendChild(td);
  });

  // === 経営全体合計テーブルに列追加 ===
  const totalRows = document.querySelectorAll("#totalTable tbody tr");

  // 面積行（先頭行）
  const areaTd = document.createElement("td");
  const areaInput = document.createElement("input");
  areaInput.type = "number";
  areaInput.placeholder = `面積${cropCount}`;
  areaInput.style.width = "100%"; // セル幅いっぱいに
  areaInput.oninput = calculateFixedTotal; // 入力時に再計算
  areaTd.appendChild(areaInput);
  totalRows[0].appendChild(areaTd);

  // 収入 / 変動費計 / 限界利益 / 限界利益率(再掲) にも列追加
  for (let r = 1; r < totalRows.length; r++) {
    const td = document.createElement("td");
    td.textContent = "–"; // 初期値
    totalRows[r].appendChild(td);
  }

  // 列数同期（不足/過剰セルの補正）
  syncTotalTable();
}


// totalTable の各行セル数を面積行に合わせる
function syncTotalTable() {
  const totalTable = document.getElementById("totalTable");
  const rows = totalTable.tBodies[0].rows;
  const targetCols = rows[0].cells.length; // 面積行の列数（th含む）

  for (let r = 1; r < rows.length; r++) {
    // 不足分を追加
    while (rows[r].cells.length < targetCols) {
      const td = document.createElement("td");
      td.textContent = "–";
      rows[r].appendChild(td);
    }
    // 過剰分を削る
    while (rows[r].cells.length > targetCols) {
      rows[r].deleteCell(-1);
    }
  }
}

function getInputValue(cell) {
  const input = cell.querySelector('input');
  return input ? parseFloat(input.value) || 0 : 0;
}

function calculateCrop(colIndex) {
  const cropRows = document.querySelectorAll("#cropTable tbody tr");
  const yieldCell = cropRows[0].cells[colIndex];
  const priceCell = cropRows[1].cells[colIndex];
  const salesCell = cropRows[2].cells[colIndex];
  const otherIncomeCell = cropRows[3].cells[colIndex];
  const totalIncomeCell = cropRows[4].cells[colIndex];
  const yieldVal = getInputValue(yieldCell);
  const priceVal = getInputValue(priceCell);
  const otherIncome = getInputValue(otherIncomeCell);
  const sales = yieldVal * priceVal;    //10a販売額か
  const totalIncome = sales + otherIncome;
  salesCell.textContent = sales.toFixed(0);
  totalIncomeCell.textContent = totalIncome.toFixed(0);

  const costRows = document.querySelectorAll("#costTable tbody tr");
  const materialCell = costRows[0].cells[colIndex];
  const laborCell = costRows[1].cells[colIndex];
  const otherCostCell = costRows[2].cells[colIndex];
  const totalCostCell = costRows[3].cells[colIndex];
  const marginCell = costRows[4].cells[colIndex];
  const marginRateCell = costRows[5].cells[colIndex];
  const material = getInputValue(materialCell);
  const labor = getInputValue(laborCell);
  const otherCost = getInputValue(otherCostCell);
  const totalCost = material + labor + otherCost;
  const margin = totalIncome - totalCost;
  const marginRate = totalIncome > 0 ? (margin / totalIncome) * 100 : 0;
  totalCostCell.textContent = totalCost.toFixed(0);
  marginCell.textContent = margin.toFixed(0);
  marginRateCell.textContent = marginRate.toFixed(1) + "%";
  calculateFixedTotal();
}


//表作成
function calculateFixedTotal() {
  let totalRevenue = 0;
  let totalVariableCost = 0;

  const cropRows = document.querySelectorAll("#cropTable tbody tr");
  const costRows = document.querySelectorAll("#costTable tbody tr");

  const totalTable = document.getElementById("totalTable");
  const totalTbodyRows = totalTable.tBodies[0].rows;
  const areaRow = totalTbodyRows[0];
  const revenueRow = totalTbodyRows[1];
  const varCostRow = totalTbodyRows[2];
  const marginRow = totalTbodyRows[3];
  const marginRateRow = totalTbodyRows[4];

  const areaInputs = areaRow.querySelectorAll("input[type='number']");

  // 各作目の集計
  areaInputs.forEach((input, idx) => {
    const area = parseFloat(input.value) || 0;
    const colIndex = idx + 1; // ヘッダーthを除いた実データ列のインデックス

    const income10a = parseFloat(cropRows[4].cells[colIndex]?.textContent.replace(/,/g, "")) || 0;
    const cost10a   = parseFloat(costRows[3].cells[colIndex]?.textContent.replace(/,/g, "")) || 0;

    const factor = area / 10;

    const revenue = income10a * factor;
    const vcost   = cost10a * factor;
    const margin  = revenue - vcost;
    const mrRate  = revenue > 0 ? (margin / revenue) * 100 : 0;

    if (revenueRow.cells[colIndex]) revenueRow.cells[colIndex].textContent = revenue ? revenue.toLocaleString() : "–";
    if (varCostRow.cells[colIndex]) varCostRow.cells[colIndex].textContent = vcost ? vcost.toLocaleString() : "–";
    if (marginRow.cells[colIndex])  marginRow.cells[colIndex].textContent  = margin ? margin.toLocaleString() : "–";
    if (marginRateRow.cells[colIndex]) marginRateRow.cells[colIndex].textContent = revenue ? mrRate.toFixed(1) + "%" : "–";

    totalRevenue     += revenue;
    totalVariableCost += vcost;
  });

  const totalMargin = totalRevenue - totalVariableCost;
  const marginRate = totalRevenue > 0 ? (totalMargin / totalRevenue) * 100 : 0;

  // 固定費を <input> または <td> から取得
  const getFixedCost = labelText => {
    // 固定費のテーブルを正確に特定
    let targetFixedCostTable = null;
    document.querySelectorAll(".summary-table").forEach(table => {
      if (table.caption && table.caption.textContent.trim() === "固定費") {
        targetFixedCostTable = table;
      }
    });
    if (!targetFixedCostTable) return 0; // 見つからなければ0を返す

    const rows = targetFixedCostTable.querySelectorAll("tr"); // 固定費テーブルの行を限定して検索
    for (const row of rows) {
      const labelCell = row.children[0];
      const valueCell = row.children[1];
      if (labelCell && valueCell && labelCell.textContent.trim() === labelText) {
        const input = valueCell.querySelector("input");
        if (input) {
          return parseFloat(input.value) || 0;
        } else {
          // inputがなくてもtextContentがある場合があるので、それも考慮（例：固定費計）
          return parseFloat(valueCell.textContent.replace(/,/g, "")) || 0;
        }
      }
    }
    return 0;
  };

  const labor        = getFixedCost("人件費（円）");
  const depreciation = getFixedCost("減価償却費（円）");
  const landRent     = getFixedCost("支払地代（円）");
  const otherFixed   = getFixedCost("その他固定費（円）");
  const fixedTotal   = labor + depreciation + landRent + otherFixed;

  const profit = totalMargin - fixedTotal;
  const breakEvenRevenue = marginRate > 0 ? fixedTotal / (marginRate / 100) : 0;

  // 表の「固定費計（円）」セルも更新する
  // 変更: 固定費テーブルの特定セルを更新
  let fixedCostTableForUpdate = null;
    document.querySelectorAll(".summary-table").forEach(table => {
      if (table.caption && table.caption.textContent.trim() === "固定費") {
        fixedCostTableForUpdate = table;
      }
    });

  if (fixedCostTableForUpdate) {
      fixedCostTableForUpdate.querySelectorAll("tr").forEach(row => {
          const labelCell = row.children[0];
          const valueCell = row.children[1];
          if (labelCell && valueCell && labelCell.textContent.trim() === "固定費計（円）") {
              valueCell.textContent = fixedTotal.toLocaleString();
          }
      });
  }


  // 経営全体テーブル更新
  // ID 'managementSummary' を持つテーブルを直接参照
  const managementTable = document.getElementById("managementSummary");
  if (managementTable) {
    const setVal = (rowIndex, value) => {
      // 経営全体テーブルは既に全行<td>を持つ構造なので、既存の<td>を更新
      const targetTd = managementTable.rows[rowIndex].cells[1];
      if (targetTd) {
        targetTd.textContent =
          value !== null && value !== undefined && !isNaN(value)
            ? Math.round(value).toLocaleString() // 四捨五入して整数表示
            : "–";
      }
    };

    const totalOtherIncome = Array.from(areaInputs).reduce((sum, input, idx) => {
      const colIndex = idx + 1;
      // cropRows[3] は 10aその他収入（円）の行
      const otherIncomeInput = cropRows[3].cells[colIndex]?.querySelector("input");
      const otherIncome10a = otherIncomeInput ? (parseFloat(otherIncomeInput.value) || 0) : 0;
      const area = parseFloat(input.value) || 0;
      return sum + (otherIncome10a * (area / 10));
    }, 0);

    const totalSales = totalRevenue - totalOtherIncome;

    setVal(0, totalSales);                          // 販売額
    setVal(1, totalOtherIncome);                    // その他収入
    setVal(2, totalRevenue);                        // 収入
    setVal(3, totalVariableCost);                   // 変動費 
    setVal(4, totalMargin);                         // 限界利益
    setVal(5, totalVariableCost + fixedTotal);      // 費用 (変動費と固定費の合計)
    setVal(6, profit);                              // 利益
    setVal(7, breakEvenRevenue);                    // 損益分岐点
  }

  drawStackedChart();
}


// CSV出力
function tableToCSV() {
  let csv = [];
  document.querySelectorAll("table").forEach(table => {
    // <caption>も行データとして出力
    if (table.caption) {
        // キャプションにカンマやダブルクォーテーションが含まれる場合はエスケープ
        let captionText = table.caption.textContent.trim();
        if (captionText.includes(",") || captionText.includes("\n") || captionText.includes('"')) {
            captionText = `"${captionText.replace(/"/g, '""')}"`;
        }
        csv.push(captionText);
    }

    // テーブルの全行をループ
    Array.from(table.rows).forEach(row => { // HTMLCollectionをArrayに変換
      let rowData = [];
      Array.from(row.querySelectorAll("th, td")).forEach(cell => {
        let val = "";
        const input = cell.querySelector("input");
        if (input) {
          val = input.value;
        } else {
          // テキストコンテンツがある場合、それを使用
          val = cell.textContent.trim();
        }
        // 数値のカンマを削除（CSV保存時に邪魔になるため）
        if (!isNaN(parseFloat(val.replace(/,/g, ''))) && val.includes(',')) {
            val = val.replace(/,/g, '');
        }
        // ダブルクォーテーションや改行を含む場合はエスケープ
        if (val.includes(",") || val.includes("\n") || val.includes('"')) {
          val = `"${val.replace(/"/g, '""')}"`;
        }
        rowData.push(val);
      });
      csv.push(rowData.join(","));
    });
    csv.push(""); // 各テーブルの終わりに空行
  });
  return csv.join("\n");
}

function downloadCSV() {
  const csvData = tableToCSV();

  const now = new Date();
  const year = now.getFullYear();
  const month = String(now.getMonth() + 1).padStart(2, '0');
  const day = String(now.getDate()).padStart(2, '0');
  const hours = String(now.getHours()).padStart(2, '0');
  const minutes = String(now.getMinutes()).padStart(2, '0');
  const fileName = `変動損益計算書_${year}${month}${day}_${hours}${minutes}.csv`;

  // SJIS変換
  const sjisArray = Encoding.convert(Encoding.stringToCode(csvData), 'SJIS', 'UNICODE');
  const uint8Array = new Uint8Array(sjisArray);
  const blob = new Blob([uint8Array], { type: "application/octet-stream" });

  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = fileName;
  a.click();
  URL.revokeObjectURL(a.href);
}

function uploadCSV(event) {
  const file = event.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = function(e) {
    const codes = Encoding.convert(new Uint8Array(e.target.result), 'UNICODE', 'SJIS');
    const text = Encoding.codeToString(codes);
    // 空行をトリムしてフィルター
    const lines = text.split(/\r?\n/).map(line => line.trim()).filter(line => line !== ""); 

    // 既存の作目列をクリアして、初期状態に戻す
    clearCrops();

    // CSVデータをすべてパースしておく
    const parsedCsv = lines.map(line => 
      line.split(',').map(v => v.replace(/^"|"$/g, '').replace(/""/g, '"'))
    );

    let cropNames = [];
    
    // 作目ヘッダー行（例: "作目,作目1,作目2..."）を見つける
    for (let i = 0; i < parsedCsv.length; i++) {
      if (parsedCsv[i][0] === "作目") { // CSVの最初の列が「作目」の行を探す
        // 1列目を除き、空でない作目名を取得
        cropNames = parsedCsv[i].slice(1).filter(name => name.trim() !== ""); 
        break;
      }
    }

    if (cropNames.length === 0) {
      alert("CSVから作目名を検出できませんでした。デフォルトの5作目を設定します。");
      for(let i=0; i<5; i++) addCrop(); // 作目が見つからない場合はデフォルトで5作目作成
    } else {
      cropNames.forEach(name => addCrop(name)); // CSVから読み取った作目名で動的に作目を追加
    }
    
    // データ割り当てロジック
    // 各HTMLテーブルをループし、CSVの対応するブロックからデータを取得して設定
    document.querySelectorAll("table").forEach(table => {
      let tableStartCsvRowIdx = -1;
      
      // 各テーブルのキャプションに基づいてCSVの開始行を特定
      if (table.caption?.textContent === "作目別収入") {
        tableStartCsvRowIdx = lines.findIndex(line => line.startsWith("作目,"));
      } else if (table.caption?.textContent === "10aあたり変動費、限界利益") {
        tableStartCsvRowIdx = lines.findIndex(line => line.startsWith("10a資材費（円）,"));
      } else if (table.caption?.textContent === "面積との関係") {
        tableStartCsvRowIdx = lines.findIndex(line => line.startsWith("面積（a）,"));
      } else if (table.caption?.textContent === "固定費") {
        tableStartCsvRowIdx = lines.findIndex(line => line.startsWith("人件費（円）,"));
      } else if (table.caption?.textContent === "経営全体") {
        tableStartCsvRowIdx = lines.findIndex(line => line.startsWith("販売額（円）,"));
      }
      
      if (tableStartCsvRowIdx === -1) {
          // 対応するCSVブロックが見つからない場合はスキップ
          console.warn(`CSVでテーブル ${table.id || table.caption?.textContent} の開始行が見つかりませんでした。`);
          return; 
      }

      // 各HTMLテーブルの行にCSVデータを割り当てる
      // <caption>の行は含まないでテーブルの実際の行データを処理する
      Array.from(table.rows).forEach((htmlRow, r_html) => {
        // CSVの対応する行インデックスは、テーブルの開始CSV行 + HTMLテーブル内の行インデックス
        // downloadCSVで出力する際にcaptionは別行に出力されるため、ここではcaption行を考慮しない
        // HTMLテーブルの実際の行 `r_html` とCSVの `tableStartCsvRowIdx + r_html` を対応させる
        const csvCurrentLine = parsedCsv[tableStartCsvRowIdx + r_html];
        
        if (!csvCurrentLine) {
            console.warn(`CSVのデータが不足しています。テーブル ${table.caption?.textContent} の行 ${r_html} に対応するデータがありません。`);
            return;
        }

        Array.from(htmlRow.querySelectorAll("th, td")).forEach((cell, i_cell) => {
          // CSVデータの該当列から値を取得
          const csvValue = csvCurrentLine[i_cell]; 

          if (csvValue !== undefined) {
            const input = cell.querySelector("input");
            if (input) {
              // input要素にはCSVの値をそのまま設定
              input.value = csvValue.trim();
            } else {
              // input要素がないセル（計算結果表示セルなど）は、CSVの値で更新しない
              // 計算結果は calculateCrop/calculateFixedTotal で再計算されるため
            }
          }
        });
      });
    });

    // 読み込み後、すべての計算を再実行
    // 作目数に応じて各作目の計算を呼ぶ
    for (let i = 1; i <= cropCount; i++) {
      calculateCrop(i);
    }
    // 全体の計算を呼ぶ
    calculateFixedTotal();
    
    // 音声説明の更新
    applySpeechAttributesToCells();
    attachSpeechListeners();
  };

  reader.readAsArrayBuffer(file);
}


// 音声説明のイベント設定
function attachSpeechListeners() {
  document.querySelectorAll('.speak-on-hover').forEach(el => {
    // 既存のイベントリスナーが重複しないように一度削除
    el.removeEventListener('mouseover', handleMouseOverSpeech); 
    // 新しい（または更新された）イベントリスナーを追加
    el.addEventListener('mouseover', handleMouseOverSpeech);
  });
}

function handleMouseOverSpeech() {
  if (!isSpeechEnabled) { // 音声が無効化されている場合は何もしない
    return;
  }
  speechSynthesis.cancel(); // 前の発声をキャンセル
  const utterance = new SpeechSynthesisUtterance(this.dataset.speech); // 'this' はイベント発生元の要素
  utterance.lang = "ja-JP";
  utterance.rate = 1.6; // ← 読み上げ速度（1.0が標準、最大は10）
  speechSynthesis.speak(utterance);
}


// 初期読み込み時：表内に音声属性を追加
const speechMap = {
  "収入（円）": "収入は、変動費と固定費に利益を加えた金額と同額です",
  "10a収入計（円）": "10アール収入計は、10アール販売額（円）と10アールその他収入（円）の合計額です",  
  "10a限界利益（円）": "限界利益は、収入から変動費を引いた金額です",
  "限界利益（円）": "限界利益は、収入から変動費を引いた金額です",
  "10aその他収入（円）": "10アールその他収入は、面積に応じて変わる10アールのそのほかの収入です",
  "10a資材費（円）": "10アール資材費は、栽培こよみを見て計算した10アール分の資材費です",
  "10a作業委託費（円）": "10アール作業委託費は、面積に応じて変わる作業委託費です。", // 追加
  "10aその他変動費（円）": "10アールその他変動費は、面積に応じて変わるそのほかの変動費です",
  "10a変動費計（円）": "変動費は、面積に応じて変わる費用です",
  "変動費計（円）": "変動費は、面積に応じて変わる費用です",
  "限界利益率": "限界利益率は、収入額の中での限界利益の割合です",
  "人件費（円）": "人件費は、給与、賞与、役員報酬など労働への支払額です",  
  "減価償却費（円）": "ここでの減価償却費は、予測使用可能年数で計算しなおした減価償却費です",
  "支払地代（円）": "支払地代は、農地の賃借料など土地資源への支払額です",
  "その他固定費（円）": "その他固定費は、損益計算書から求めたそのほか固定費です",
  "利益（円）": "利益は、収入から変動費と固定費を引いた金額です",
  "損益分岐点の収入（円）": "収入が、損益分岐点の収入を下回ると赤字利益です"
  
};

document.addEventListener('DOMContentLoaded', () => {
  // applySpeechAttributesToCells()とattachSpeechListeners()はwindow.onloadで呼ばれるため、ここでは不要
  
  // 音声トグルボタンのイベントリスナー
  const toggleSpeechButton = document.getElementById('toggleSpeechButton');
  if (toggleSpeechButton) {
    toggleSpeechButton.addEventListener('click', () => {
      isSpeechEnabled = !isSpeechEnabled; // 状態を反転
      if (!isSpeechEnabled) {
        speechSynthesis.cancel(); // 音声を停止
        toggleSpeechButton.textContent = "音声出力：オフ";
        toggleSpeechButton.style.backgroundColor = "#ccc"; // オフ時のスタイル
      } else {
        toggleSpeechButton.textContent = "音声出力：オン";
        toggleSpeechButton.style.backgroundColor = ""; // オン時のスタイル (CSSで定義されたデフォルト)
      }
    });
  }

  // input要素の変更を検知してグラフを再描画
  document.querySelectorAll("input[type='number'], input[type='text'], select, textarea")
    .forEach(el => el.addEventListener("input", drawStackedChart));
  
});

// セルに音声属性を適用する関数
function applySpeechAttributesToCells() {
    document.querySelectorAll("table").forEach(table => {
        table.querySelectorAll("th, td").forEach(cell => { 
            const text = cell.textContent.trim();
            if (speechMap[text]) {
                cell.classList.add("speak-on-hover");
                cell.dataset.speech = speechMap[text];
            } else {
                // 音声説明がない場合はクラスとデータを削除 (念のため)
                cell.classList.remove("speak-on-hover");
                delete cell.dataset.speech;
            }
        });
    });
}


//描画
function drawStackedChart() {
  // 数値化ユーティリティ
  const getNum = (v) => {
    const s = String(v || "").replace(/,/g, "").trim();
    if (s === "" || s === "–") return 0;
    const n = parseFloat(s);
    return isNaN(n) ? 0 : n;
  };

  // 指定行・列のセルから、inputがあればvalue、なければtextContentを取得
  const getCellValue = (rows, r, c) => {
    const cell = rows[r]?.cells[c];
    if (!cell) return "";
    const inp = cell.querySelector("input");
    return inp ? inp.value : cell.textContent;
  };

  const cropRows   = document.querySelectorAll("#cropTable tbody tr");
  const costRows   = document.querySelectorAll("#costTable tbody tr");
  const areaInputs = document.querySelectorAll("#totalTable tbody tr:nth-child(1) input[type='number']");

  // 作目名（<input> or th.textContent）
  const cropNames = Array.from(document.querySelectorAll("#cropHeader th"))
    .slice(1) // 最初の"作目"thを除外
    .map(th => {
      const inp = th.querySelector("input");
      return inp ? inp.value.trim() : th.textContent.trim(); // inputがあればそのvalue、なければtextContent
    })
    .map(n => n || "未設定"); // 名前が空の場合は"未設定"

  let totalSales        = 0;
  let totalOtherIncome  = 0;
  let totalVariableCost = 0;
  const cropMargins     = [];

  // 面積でスケーリングして集計
  areaInputs.forEach((input, idx) => {
    const area    = getNum(input.value);
    const factor  = area / 10;
    const col     = idx + 1; // ヘッダーthを除いた実データ列のインデックス

    // 各セルの値を取得
    const sales10a       = getNum(cropRows[2].cells[col]?.textContent); // salesCell.textContentから取得
    const otherInc10a    = getNum(getCellValue(cropRows, 3, col)); // inputがあればinputから
    const varCost10a     = getNum(costRows[3].cells[col]?.textContent); // totalCostCell.textContentから取得
    const margin10a      = getNum(costRows[4].cells[col]?.textContent); // marginCell.textContentから取得

    totalSales        += sales10a * factor ;　/////////10a販売額
    totalOtherIncome  += otherInc10a * factor;
    totalVariableCost += varCost10a * factor;
    cropMargins.push(margin10a * factor);
  });

  const revenue = totalSales + totalOtherIncome;
  const margin  = revenue - totalVariableCost;

  // 固定費集計
  const labor        = getNum(document.getElementById("laborCost")?.value);
  const depreciation = getNum(document.getElementById("depreciation")?.value);
  const landRent     = getNum(document.getElementById("landRent")?.value);
  const otherFixed   = getNum(document.getElementById("otherFixed")?.value);
  const fixedTotal   = labor + depreciation + landRent + otherFixed;

  const costTotal = totalVariableCost + fixedTotal;
  const profit    = margin - fixedTotal;

  // 既存チャートを破棄
  if (window.stackedChartInstance) window.stackedChartInstance.destroy();

  // グラフ描画
const ctx = document.getElementById("stackedChart").getContext("2d");
window.stackedChartInstance = new Chart(ctx, {
  type: "bar",
  data: {
    labels: ["収入", "販売＋その他", "費用＋利益", "限界利益", "作目別限界利益"],
    datasets: [
      { label: "収入", data: [revenue, 0, 0, 0, 0], backgroundColor: "#4682b4", stack: "stack1", barThickness: 250 },
      { label: "販売額", data: [0, totalSales, 0, 0, 0], backgroundColor: "#3cb371", stack: "stack1", barThickness: 250 },
      { label: "その他収入", data: [0, totalOtherIncome, 0, 0, 0], backgroundColor: "#90ee90", stack: "stack1", barThickness: 250 },
      { label: "変動費", data: [0, 0, totalVariableCost, totalVariableCost, totalVariableCost], backgroundColor: "#f08080", stack: "stack1", barThickness: 250 },
      { label: "固定費", data: [0, 0, fixedTotal, 0, 0], backgroundColor: "#ffa07a", stack: "stack1", barThickness: 250 },
      { label: "利益", data: [0, 0, profit, 0, 0], backgroundColor: "#87cefa", stack: "stack1", barThickness: 250 },
      { label: "限界利益（全体）", data: [0, 0, 0, margin, 0], backgroundColor: "#6495ed", stack: "stack1", barThickness: 250 },
      // 各作目の限界利益データセットを動的に生成
      ...cropMargins.map((val, i) => ({
        label: `${cropNames[i]} 限界利益`,
        data: [0, 0, 0, 0, val], // 作目別限界利益のデータは最後のラベルに対応
        backgroundColor: ["#ffd700", "#ffb6c1", "#dda0dd", "#98fb98", "#87ceeb", "#add8e6", "#ffc0cb", "#7fffd4", "#fa8072", "#afeeee"][i % 10], // 配色パターンを増やす
        stack: "stack1",
        barThickness: 250
      }))
    ]
  },
  options: {
    responsive: true,
    scales: {
      x: {
        stacked: true,
        categoryPercentage: 0.9,
        barPercentage: 1.0,
        ticks: {
          font: {
            size: 18,
            weight: "bold"
          }
        }
      },
      y: {
        stacked: true,
        beginAtZero: true,
        title: {
          display: true,
          text: "金額（円）",
          font: {
            size: 18,
            weight: "bold"
          }
        },
        ticks: {
          font: {
            size: 20
          }
        }
      }
    },
    plugins: {
      legend: { display: false },
      datalabels: {
        color: "#000",
        font: { weight: "bold", size: 20 },
        formatter: (value, ctx) => value
          ? `${ctx.dataset.label}\n${Math.round(value).toLocaleString()}円`
          : ""
      },
      title: {
        display: true,
        text: "農業経営の収支構成",
        font: {
          size: 24,
          weight: "bold"
        },
        padding: { top: 8, bottom: 12 }
      }
    }
  },
  plugins: [ChartDataLabels]
});

  // 損益分岐点計算
  const cmRatio            = revenue > 0 ? (margin / revenue) : 0;
  const breakEvenRevenue   = cmRatio > 0 ? (fixedTotal / cmRatio) : 0;

  // 経営全体表へ反映
  const setTxt = (id, val, frac = 0) => {
    const el = document.getElementById(id);
    if (!el) return;
    el.textContent = frac > 0
      ? Number(val).toLocaleString(undefined, { maximumFractionDigits: frac })
      : Math.round(Number(val)).toLocaleString();
  };

  setTxt("sumSales",       totalSales);
  setTxt("sumOtherIncome", totalOtherIncome);   // ← ここに正しい値が入るようになります
  setTxt("sumRevenue",     revenue);
  setTxt("sumVarCost",     totalVariableCost);
  setTxt("sumMargin",      margin);
  setTxt("sumCostTotal",   costTotal); // 修正後の費用
  setTxt("sumProfit",      profit);
  setTxt("sumBreakEven",   breakEvenRevenue);
}

//自動貼付
function applyValueToCell(storageKey, labelText) {
  const value = localStorage.getItem(storageKey);
  if (value !== null) {
    // captionで固定費テーブルを特定
    let fixedCostTable = null;
    document.querySelectorAll(".summary-table").forEach(table => {
      if (table.caption && table.caption.textContent.trim() === "固定費") {
        fixedCostTable = table;
      }
    });
    if (!fixedCostTable) return;

    fixedCostTable.querySelectorAll("tr").forEach(row => {
      const labelCell = row.children[0];
      const valueCell = row.children[1];
      if (labelCell && valueCell && labelCell.textContent.trim() === labelText) {
        const input = valueCell.querySelector("input"); // input要素があればvalueを設定
        if(input) {
            input.value = parseInt(value);
        } else {
            // inputがない場合はtextContentを更新（例：固定費計）
            valueCell.textContent = parseInt(value).toLocaleString(); 
        }
      }
    });
  }
}

// データ取り込みボタンのイベントリスナーはDOMContentLoadedで設定
document.addEventListener("DOMContentLoaded", () => {
  // 既存のDOMContentLoadedの内容に加えて、storageからの初期値適用もここで行う
  // ページロード時にもlocalStorageの値を適用する
  applyValueToCell("otherFixedCostValue", "その他固定費（円）");
  applyValueToCell("depreciationTotalValue", "減価償却費（円）");
  applyValueToCell("laborCostValue", "人件費（円）"); 
  applyValueToCell("landRentCostValue", "支払地代（円）"); 

  document.getElementById("importFixedCosts").addEventListener("click", importFixedCostsFromStorage);
});


//データ取り込み
function importFixedCostsFromStorage() {
  const applyValueToSpecificFixedCostCell = (storageKey, labelText) => {
    const value = localStorage.getItem(storageKey);
    if (value !== null) {
      let fixedCostTable = null;
        document.querySelectorAll(".summary-table").forEach(table => {
            if (table.caption && table.caption.textContent.trim() === "固定費") {
                fixedCostTable = table;
            }
        });
      if (!fixedCostTable) return;

      fixedCostTable.querySelectorAll("tr").forEach(row => {
        const labelCell = row.children[0];
        const valueCell = row.children[1];
        if (labelCell && valueCell && labelCell.textContent.trim() === labelText) {
          const input = valueCell.querySelector("input");
          if (input) {
            input.value = parseFloat(value); // 数値として設定
          }
        }
      });
    }
  };

  // すべての固定費項目を取り込む
  applyValueToSpecificFixedCostCell("laborCostValue", "人件費（円）");
  applyValueToSpecificFixedCostCell("depreciationTotalValue", "減価償却費（円）");
  applyValueToSpecificFixedCostCell("landRentCostValue", "支払地代（円）");
  applyValueToSpecificFixedCostCell("otherFixedCostValue", "その他固定費（円）");

  calculateFixedTotal(); // 固定費を取り込んだ後、全体の再計算と表示更新

  alert("固定費データを取り込みました");
}


</script>
</body>
</html>